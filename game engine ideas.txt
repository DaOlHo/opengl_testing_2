~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    GAME ENGINE V1 IDEAS:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Has a handful of widgets:
 - 3D environment window(? possibly)
 - Background (branch into separate scripting later, so you can have
   it act as a visualizer)
 - Image
 - Nametag (nametag for person with custom coords, e.g. if the image
   has someone's whole body in it, you can focus on just their face)
 - Portrait (Image + Nametag combined)
 - Text (Fixed width and height, in monospaced characters width-wise
   and lines heigh-wise, wrapping by word and characters over the limit
   are cropped)
 - Close widget (closes the widget provided)
 - Background sound widget (plays audio on loop until close)
 - Play sound widget (plays audio and closes when it completes)

General syntax for scripting (NOT FINAL!):

[<widget name> <widget id>]
(param1 = foo, param 2 = bar)
<text, if applicable>

Example text widget:

[Text sample_text]
(width = 20, height = 1, x = 0, y = 0, depth = 0)
Hello, how are you?	
wonderful weather we are having, huh
[Close sample_text]

Text notes:
 - Text is the only widget that has the strings following declaration
 - Text starts always on the first line, after it has animated in
 - Remains on last text until closed
 - Will need to find a way to tag text blocks, e.g. sample_text="hello",
   or sample_text=[], etc
 - Force multi-line text blocks would be written surrounded with "" (
   This would override word wrapping on >1 height text widgets)
 - Options to change wrapping?
 - Let user define sound that plays when letter is drawn, or if it is one sound that plays
   while the text is drawing, etc. (probably a V1.5 feature)
 - Add support for seperate sounds and separate times, e.g. different sound
   when newline, different sound when block of text is completed, etc
 - Basic support for a span-like element where you can bold, italicize, change the color, etc
   of specific text to achieve desired effects

Other notes:
 - Might need to change to a more C like syntax?
 - Depth parameter, if not specified a new widget gets put to the top
 - You can do multiple things at one press with a {} block, e.g:
   {
	[Close sample_1]
	[Close sample_2]
   }
 - Styling on windows is hard coded in V1, will switch out later
 - {} blocks need parameters to set how they behave, e.g. whether they
   all animate in at the same time, or with x delay in order of
   declaration, or after eachother, etc
 - Game engine name is some synonym of film window, obviously
 - For V1, just declare window size in header
 - use .glsl for shaders
 - V1 is a proof of concept, past that you would need to introduce a graphical editor
   that uses "frames" and adds a lot more graphical customization to keep it under
   the "evan principle"
 - Evan Principle = "the engine should be easy to use for someone reasonably
   comfortable with computers, but who cannot program in the slightest, enabling fast
   and efficient creation of visual novels that mimics a movie script"
 - Later add extensibility through custom modules and stuff
 - Make the engine so good you secretly make more film window silver case-eque games,
   meaning more shit to play!
 - 3D rendering scenes are rendered to a different frame buffer and bind it to a texture
   that is then drawn like a mirror
 - Eventually you might even be able to add post processing effects to the 3D-windows
 - Maybe have an option where you can use legacy script writing or lua for more control
 - Picture widgets can change pictures without being re-animated in, simulate flipping
   slides or changing expressions in a sprite
 - Be sure to encapsulate all opengl functions to make everything less ew
 - Try out pure rust alternative to GLFW: https://github.com/rust-windowing/glutin
 - Make sure to find the best libraries from here: https://arewegameyet.rs/#ecosystem
 - Most sensible way to do more advanced things might be to make the "engine" be its own crate
   that you can import so you can use rust in a unity-like way to interface with the engine
   (e.g. engine.render_loop variable can be bound a function where everything is abstracted
   except transformations and the like, similar to unity)
 - Could bypass the entire markdown format by having an option to just code a similar thing
   but in rust and taking advantage of its quirks to implement the functions
 - The markdown replacement could be in its own function, then all that happens in the main
   loop is binding the function to a thing in the library/engine
 - This way you can have both the possibility for markdown style declaration of events and
   native and intuitive support for extremely advanced features right out of the box, with
   no inclusion of LUA or other abstracting libraries, allowing for an extremely performant
   with no sacrifices on usability for less experienced game devs
 - While loading screens are custom, have a variable that keeps getting changed that says what
   is currently being loaded, so you could have loading screens that say "creating depth maps"
   for example
 - Document code automatically with rust generator thing, put comments
   above functions and the like and see if you can make it generate
   docs based on that
 - Use models to generate array of texture ids, might be faster then doing it
   every mesh, same with textures (basically consolidate as many OpenGL calls
   as you can)
 - Read this (https://www.khronos.org/opengl/wiki/Common_Mistakes) VERY thoroughly
 - https://stackoverflow.com/questions/17092075/what-is-the-point-of-the-textarget-parameter-for-glframebuffertexture
 - Set option for logging level in final engine, which includes OpenGL callbacks
 - eventually add vulkan and dx12
 - with multiple supported graphics libs, add option to restrict them (e.g. for if you want to support ray tracing)
 - Create a system for hot reloading the game when you change something small like a position of something, instead of
   having to re-compile and re-load all the assets again
    - Could have a button that gets cargo to build, then pass in command line arguments for a kind of hot-restart
      - Take advantage of the fact the rust builder doesn't completely re-compile the program in debug mode
      - These methods would still require a full reload if lower level parts of the engine are changed, but that
        doesn't matter as it was expected anyways
      - Take advantage of rust's conditional compilation (debug_assertions) to compile out hot-reload code when building
        in release, to optimize the resulting executable further
      - Command line arguments include an asset and associated texture and vertex buffer IDs, which then are re-
        used in the re-compiled program instead of loading the assets again, then have a check to delete un-used
        IDs
      - This could even work for shader compilation, though there is a shader hot-reload button already
      - Remember to have checks to not release the resources on the GPU if there is a hot restart in progress
      - Look into if there is a process to recompile while keeping the same window object and re-binding an opengl
        context, or if there is a way to transfer those contexts
      - See if there is a way to hook into vscode's debug system for a hot-restart button there
      - Track what would need to be fully re-compiled (e.g. if you change to support vulkan as well, force a full
        recompilation)
      - Since this is invasive, possibly require it to be enabled in case you don't want it to break other things
        depending on your dev environment
      - Could deal with needing to build multiple exes in one folder without overwriting (since one is still running)
        by having up to 10 exes that are appended with a timestamp, then have the build script for debug clear all
        previous exes (could also have an exe that is being hot-reloaded into clear out the exe that existed before
        it)
    - If above is unfeasable (and I will try my damndest to make it), then have the engine throw all changes in an
      interpreted file for hot-restart, then in release compile it
        - This would once again have issues with changing lower level things, but you could choose to enable/disable
          this feature when working in lower level sections of the engine
        - Could combine this with the previous method to have a hot-reload/hot-restart paradigm similar to flutter's
 - Allow switching for prefered graphics library when multiple are supported, maybe even WebGL at some point
 - Be very aggressive to remove un-used code (e.g. vulkan support if it is not enabled) to keep speed up and size down
 - Make sure to allow for dynamic switching of styling, e.g. have a text crawl at the start that is styled like a computer
   terminal, meanwhile normal text looks different.
 - Design could be that you have an engine namespace -> core namespace -> GL specific namespace, so
   that the switching can be handled by the game maker with command line arguments, to allow for things such as the
   steam GL selection dialogue to work
 - Allow for usage of either tts executable (could be used to generate voice mumble) or sound file for text, able to be set
   or reset depending on whether you want voice acting or just one sound normally, supports per text write sound as well as
   whole line sound (for voice acting vs the type writer sound effects of tsc), and everything is able to be rebound
   dynamically
 - Could have the main set of defined things be an array that is iterated over by the engine, which could use the fact
   that everything in rust can be an expression with curly braces
 - Possible even have the ability to pass functions which are then called into it, maybe using the way enums work
 - Have some way to set multiple styling templates, a default template, etc to lower repeated code
 - Could also have widget structs that hold all that info that handle drawing one or multiple widgets with their info
 - Possibly allow support for parsing of text files as well to simplify script writing
 - Could also use concurrency/await for each call, for example to get a response from a menu you could do:
   let response: u32 = await Menu.draw(["opt1", "opt2"]; where the returned number is an index
 - Have an array of widgets that implement the draw trait (custom traits have to be a thing right?), and then
   render each widget in the array in the order they are in the array on a 2D plane without depth testing,
   so that first in is first drawn and so on. allow access to this stack manually of course.
 - Start making the engine by first making a 2D draw struct that draws a background, then work your way up to the rest
   of the widgets, implement styling and animations, move to 3D then to input and sound, etc
 - Naturally use a return type of Result<(), Box<dyn Error>> on main for easier error handling
 - Use flutter widgets as a basis of what properties certain widgets have, for example text widgets have similar props
   to flutter textstyle, etc.
 - Background could be rendered as an ortho 3D image for more complex visualized shapes